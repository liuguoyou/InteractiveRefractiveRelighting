#version 330   


uniform vec3 u_light;
uniform bool is_voxel_fs;
uniform bool is_depth_fs;
uniform bool is_sky_box_fs;
uniform bool is_transparent_mesh_fs;

uniform sampler2D skyBoxColorTex;
uniform sampler2D skyBoxRadianceTex;
uniform sampler2D meshColorTex;
uniform sampler2D meshRadianceTex;

in vec3 fs_position;
in vec3 fs_normal;
in vec3 fs_color;
in vec3 fs_meshpos;
in vec2 fs_texcoord;
in vec3 fs_bounding_min;
in vec3 fs_bounding_max;

out vec4 frag_color;




// automatically generated by GenerateGaussFunctionCode in GaussianBlur.h                                                                                            
vec3 GaussianBlur( sampler2D tex0, vec2 centreUV, vec2 halfPixelOffset, vec2 pixelOffset )                                                                           
{                                                                                                                                                                    
    vec3 colOut = vec3( 0, 0, 0 );                                                                                                                                   
                                                                                                                                                                     
    // Kernel width 11 x 11
    const int stepCount = 3;
    float gWeights[stepCount];
    gWeights[0] = 0.33023;
    gWeights[1] = 0.15701;
    gWeights[2] = 0.01276;

    float gOffsets[stepCount];
    gOffsets[0] = 0.62184;
    gOffsets[1] = 2.27310;
    gOffsets[2] = 4.14653;

                                                                                                                                                                     
    for( int i = 0; i < stepCount; i++ )                                                                                                                             
    {                                                                                                                                                                
        vec2 texCoordOffset = gOffsets[i] * pixelOffset;                                                                                                           
        vec3 col = texture( tex0, centreUV + texCoordOffset ).xyz + texture( tex0, centreUV - texCoordOffset ).xyz;                                                
        colOut += gWeights[i] * col;                                                                                                                               
    }                                                                                                                                                                
                                                                                                                                                                     
    return colOut;                                                                                                                                                   
}                                                                                                                                                                    


                                                                                                                                             





void main (void){
   vec3 L = normalize(u_light - fs_position);
   vec3 E = normalize(-fs_position); // we are in Eye Coordinates, so EyePos is (0,0,0) 
   vec3 R = normalize(-reflect(L, fs_normal));

   //fs_texcoord = fs_texcoord / sqrt(fs_texcoord.x*fs_texcoord.x + fs_texcoord.y*fs_texcoord.y);
   //float alpha = distance(fs_texcoord, vec2(0.5,0.5)) / 0.707;
   float alpha = 0.5;
   

   
   if(is_voxel_fs) {
      alpha = 0.45;
      //calculate Ambient Term:
      vec4 Iamb = vec4(0.1*fs_color, alpha);
         //calculate Diffuse Term:
      vec4 Idiff = vec4(0.45*fs_color, alpha) * max(dot(fs_normal,L), 0.0);
      Idiff = clamp(Idiff, 0.0, 1.0);
         // calculate Specular Term:
      vec4 Ispec = vec4(0.45*fs_color, alpha)
                   * pow(max(dot(R, E), 0.0), 0.3 * 4.0);
      Ispec = clamp(Ispec, 0.0, 1.0);
      // write Total Color:
      frag_color = Iamb + Idiff + Ispec;

      if(is_sky_box_fs)
         frag_color = vec4(fs_color, 1.0);

   } 
   else if (is_depth_fs) {
      frag_color = vec4(fs_meshpos.xyz, 1.0);
   } 
   else if(is_sky_box_fs){
      vec2 texelSize = 1.0 / vec2(textureSize(skyBoxRadianceTex, 0));

      vec4 color = texture(skyBoxColorTex, fs_texcoord);
      //vec4 radiance = texture(skyBoxRadianceTex, fs_texcoord);
      vec4 radiance = vec4(GaussianBlur(skyBoxRadianceTex, fs_texcoord, vec2(0,0), texelSize), 1.0);
      frag_color = color + radiance*0.09;

      // single scattering light
      texelSize = 1.0 / vec2(textureSize(meshRadianceTex, 0));
      vec2 screenCoords = gl_FragCoord.xy * texelSize;
      //frag_color += texture(meshRadianceTex, screenCoords); 
      frag_color += 0.1*vec4(GaussianBlur(meshRadianceTex, screenCoords, vec2(0,0), texelSize), 1.0); 

   } 
   else if (is_transparent_mesh_fs) {
      vec2 texelSize = 1.0 / vec2(textureSize(meshColorTex, 0));
      vec2 screenCoords = gl_FragCoord.xy * texelSize;

      //vec4 color = texture(meshColorTex, screenCo ords);
      vec4 color = vec4(GaussianBlur(meshColorTex, screenCoords, vec2(0,0), texelSize), 1.0);

      vec4 color2 = texture(meshRadianceTex, screenCoords); 
      //frag_color = color + 0.01*vec4(GaussianBlur(meshRadianceTex, screenCoords, vec2(0,0), texelSize), 1.0); 
      frag_color = color + 0.02*color2;


      /*
      if((fs_meshpos-fs_bounding_min).y > (fs_bounding_max - fs_bounding_min).y / 4.0)
        color = vec4(0.0314,0.1059,0.6941,1.0);
      else
        color = vec4(0.8549,0.3137,0.0784,1.0);
      vec4 Iamb = color;
      vec4 Idiff = color * max(dot(fs_normal,L), 0.0);
      Idiff = clamp(Idiff, 0.0, 1.0);
      */
      vec4 Ispec = color * pow(max(dot(R, E), 0.0), 2.0 * 4.0);
      Ispec = clamp(Ispec, 0.0, 1.0);

      //frag_color = 0.2*Idiff + 0.8*(texture(meshColorTex, screenCoords) + texture(meshRadianceTex, screenCoords)*0.0009);
      //frag_color = max(frag_color, 0.3*vec4((Iamb + Idiff + Ispec).rgb, 1.0)); 
      frag_color += (Ispec);     
   } 
   else {
      vec4 color = vec4(fs_color, alpha);
      color = vec4(1.0,0.5,0.2,1.0);

      //calculate Ambient Term:
      
      vec4 Iamb = color;//vec4(0.388, 0.239, 0.129, 1.0);
      //calculate Diffuse Term:
      vec4 Idiff = color * max(dot(fs_normal,L), 0.0);
      Idiff = clamp(Idiff, 0.0, 1.0);
         // calculate Specular Term:
      vec4 Ispec = color//vec4(0.953, 0.820, 0.627, 1.0)
                   * pow(max(dot(R, E), 0.0), 0.7 * 4.0);
      Ispec = clamp(Ispec, 0.0, 1.0);
      // write Total Color:
      frag_color = vec4((Iamb + Idiff + Ispec).rgb, alpha);

   }

}