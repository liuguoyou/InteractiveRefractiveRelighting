#version 330   


uniform vec3 u_light;
uniform bool is_voxel_fs;
uniform bool is_depth_fs;
uniform bool is_sky_box_fs;
uniform bool is_transparent_mesh_fs;

uniform sampler2D skyBoxColorTex;
uniform sampler2D skyBoxRadianceTex;
uniform sampler2D meshColorTex;
uniform sampler2D meshRadianceTex;

in vec3 fs_position;
in vec3 fs_normal;
in vec3 fs_color;
in vec3 fs_meshpos;
in vec2 fs_texcoord;
in vec3 fs_bounding_min;
in vec3 fs_bounding_max;

out vec4 frag_color;




// automatically generated by GenerateGaussFunctionCode in GaussianBlur.h                                                                                            
vec3 GaussianBlur( sampler2D tex0, vec2 centreUV, vec2 halfPixelOffset, vec2 pixelOffset )                                                                           
{                                                                                                                                                                    
    vec3 colOut = vec3( 0, 0, 0 );                                                                                                                                   
                                                                                                                                                                     
    // Kernel width 11 x 11
    const int stepCount = 3;
    float gWeights[stepCount];
    gWeights[0] = 0.33023;
    gWeights[1] = 0.15701;
    gWeights[2] = 0.01276;

    float gOffsets[stepCount];
    gOffsets[0] = 0.62184;
    gOffsets[1] = 2.27310;
    gOffsets[2] = 4.14653;

                                                                                                                                                                     
    for( int i = 0; i < stepCount; i++ )                                                                                                                             
    {                                                                                                                                                                
        vec2 texCoordOffset = gOffsets[i] * pixelOffset;                                                                                                           
        vec3 col = texture( tex0, centreUV + texCoordOffset ).xyz + texture( tex0, centreUV - texCoordOffset ).xyz;                                                
        colOut += gWeights[i] * col;                                                                                                                               
    }                                                                                                                                                                
                                                                                                                                                                     
    return colOut;                                                                                                                                                   
}                                                                                                                                                                    

           
vec4 rgb_to_hsl (vec4 rgb)
{
  float maxx, minn, delta;


  maxx = max(rgb.x, max(rgb.y, rgb.z));
  minn = min(rgb.x, min(rgb.y, rgb.z));

  vec4 hsl = vec4(0.,0.,0.,0.);

  hsl.z = (maxx + minn) / 2.0;

  if (maxx == minn)
    {
      hsl.y = 0.0;
      hsl.x = -1.0;
    }
  else
    {
      if (hsl.z <= 0.5)
        hsl.y = (maxx - minn) / (maxx + minn);
      else
        hsl.y = (maxx - minn) / (2.0 - maxx - minn);

      delta = maxx - minn;

      if (delta == 0.0)
        delta = 1.0;

      if (rgb.x == maxx)
        {
          hsl.x = (rgb.y - rgb.z) / delta;
        }
      else if (rgb.y == maxx)
        {
          hsl.x = 2.0 + (rgb.z - rgb.x) / delta;
        }
      else
        {
          hsl.x = 4.0 + (rgb.x - rgb.y) / delta;
        }

      hsl.x /= 6.0;

      if (hsl.x < 0.0)
        hsl.x += 1.0;
    }

  hsl.w = rgb.w;

  return hsl;
}                                                                                                                                  




float hsl_value (float n1,
                float n2,
                float hue)
{
  float val;

  if (hue > 6.0)
    hue -= 6.0;
  else if (hue < 0.0)
    hue += 6.0;

  if (hue < 1.0)
    val = n1 + (n2 - n1) * hue;
  else if (hue < 3.0)
    val = n2;
  else if (hue < 4.0)
    val = n1 + (n2 - n1) * (4.0 - hue);
  else
    val = n1;

  return val;
}

vec4 hsl_to_rgb (vec4 hsl)
{
  vec4 rgb = vec4(0.,0.,0.,0.);

  if (hsl.y == 0.)
    {
      /*  achromatic case  */
      rgb.x = hsl.z;
      rgb.y = hsl.z;
      rgb.z = hsl.z;
    }
  else
    {
      float m1, m2;

      if (hsl.z <= 0.5)
        m2 = hsl.z * (1.0 + hsl.y);
      else
        m2 = hsl.z + hsl.y - hsl.z * hsl.y;

      m1 = 2.0 * hsl.z - m2;

      rgb.x = hsl_value (m1, m2, hsl.x * 6.0 + 2.0);
      rgb.y = hsl_value (m1, m2, hsl.x * 6.0);
      rgb.z = hsl_value (m1, m2, hsl.x * 6.0 - 2.0);
    }

  rgb.w = hsl.w;

  return rgb;
}





void main (void){
   vec3 L = normalize(u_light - fs_position);
   vec3 E = normalize(-fs_position); // we are in Eye Coordinates, so EyePos is (0,0,0) 
   vec3 R = normalize(-reflect(L, fs_normal));

   //fs_texcoord = fs_texcoord / sqrt(fs_texcoord.x*fs_texcoord.x + fs_texcoord.y*fs_texcoord.y);
   //float alpha = distance(fs_texcoord, vec2(0.5,0.5)) / 0.707;
   float alpha = 0.5;
   

   
   if(is_voxel_fs) {
      alpha = 0.45;
      //calculate Ambient Term:
      vec4 Iamb = vec4(0.1*fs_color, alpha);
         //calculate Diffuse Term:
      vec4 Idiff = vec4(0.45*fs_color, alpha) * max(dot(fs_normal,L), 0.0);
      Idiff = clamp(Idiff, 0.0, 1.0);
         // calculate Specular Term:
      vec4 Ispec = vec4(0.45*fs_color, alpha)
                   * pow(max(dot(R, E), 0.0), 0.3 * 4.0);
      Ispec = clamp(Ispec, 0.0, 1.0);
      // write Total Color:
      frag_color = Iamb + Idiff + Ispec;

      if(is_sky_box_fs)
         frag_color = vec4(fs_color, 1.0);

   } 
   else if (is_depth_fs) {
      frag_color = vec4(fs_meshpos.xyz, 1.0);
   } 
   else if(is_sky_box_fs){
      vec2 texelSize = 1.0 / vec2(textureSize(skyBoxRadianceTex, 0));

      vec4 color = texture(skyBoxColorTex, fs_texcoord);
      //vec4 radiance = texture(skyBoxRadianceTex, fs_texcoord);
      vec4 radiance = vec4(GaussianBlur(skyBoxRadianceTex, fs_texcoord, vec2(0,0), texelSize), 1.0);
      frag_color = color + radiance*0.09;

      // single scattering light
      texelSize = 1.0 / vec2(textureSize(meshRadianceTex, 0));
      vec2 screenCoords = gl_FragCoord.xy * texelSize;
      //frag_color += texture(meshRadianceTex, screenCoords); 
      frag_color += 0.4*vec4(GaussianBlur(meshRadianceTex, screenCoords, vec2(0,0), texelSize), 1.0); 

   } 
   else if (is_transparent_mesh_fs) {
      vec2 texelSize = 1.0 / vec2(textureSize(meshColorTex, 0));
      vec2 screenCoords = gl_FragCoord.xy * texelSize;

      //vec4 color = texture(meshColorTex, screenCo ords);
      vec4 color = vec4(GaussianBlur(meshColorTex, screenCoords, vec2(0,0), texelSize), 1.0);

      //vec4 radiance = texture(meshRadianceTex, screenCoords); 
      vec4 radiance = vec4(GaussianBlur(meshRadianceTex, screenCoords, vec2(0,0), texelSize), 1.0);
      vec4 color2;
      if((fs_meshpos-fs_bounding_min).y > (fs_bounding_max - fs_bounding_min).y / 4.7)
        color2 = vec4(0.0314,0.1059,0.6941,1.0);
      else
        color2 = vec4(0.8549,0.3137,0.0784,1.0);
      vec4 color2_hsl = rgb_to_hsl(color2);
      color2_hsl.z += 0.1*(radiance.x + radiance.y + radiance.z) / 3.0;
      color2 = hsl_to_rgb(color2_hsl);
      //frag_color = color + 0.01*vec4(GaussianBlur(meshRadianceTex, screenCoords, vec2(0,0), texelSize), 1.0); 
      frag_color = color*0.95 + color2*0.05;

      vec4 Ispec = color * pow(max(dot(R, E), 0.0), 2.0 * 4.0);
      Ispec = clamp(Ispec, 0.0, 1.0);

      //frag_color = 0.2*Idiff + 0.8*(texture(meshColorTex, screenCoords) + texture(meshRadianceTex, screenCoords)*0.0009);
      //frag_color = max(frag_color, 0.3*vec4((Iamb + Idiff + Ispec).rgb, 1.0)); 
      frag_color += (Ispec);     
   } 
   else {
      vec4 color = vec4(fs_color, alpha);
      color = vec4(1.0,0.5,0.2,1.0);

      //calculate Ambient Term:
      
      vec4 Iamb = color;//vec4(0.388, 0.239, 0.129, 1.0);
      //calculate Diffuse Term:
      vec4 Idiff = color * max(dot(fs_normal,L), 0.0);
      Idiff = clamp(Idiff, 0.0, 1.0);
         // calculate Specular Term:
      vec4 Ispec = color//vec4(0.953, 0.820, 0.627, 1.0)
                   * pow(max(dot(R, E), 0.0), 0.7 * 4.0);
      Ispec = clamp(Ispec, 0.0, 1.0);
      // write Total Color:
      frag_color = vec4((Iamb + Idiff + Ispec).rgb, alpha);

   }

}